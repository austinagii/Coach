package main

import (
	"log/slog"
	"net/http"

	"aisu.ai/api/v2/cmd/server/shared/api"
	"aisu.ai/api/v2/internal/assistant"
	"aisu.ai/api/v2/internal/assistant/chat"
	"aisu.ai/api/v2/internal/assistant/task"
	"github.com/gin-gonic/gin"
)

const (
	chatNotFound api.ErrorCode = "chat_not_found"
)

type NewChatRequest struct {
	Task *task.Task `json:"task"`
}

type NewChatResponse struct {
	Id   string `json:"id"`
	Text string `json:"text"`
}

// HandleNewChatRequest processes an HTTP request to create a new chat returning
// the chat prompt generated by the assistant as a JSON response and the chat
// id in the location header.
func CreateChat(context *gin.Context) {
	request := NewChatRequest{}
	if err := context.BindJSON(&request); err != nil {
		// TODO: Add user friendly error messages for request validation.
		errMsg := "An error occurred while unmarshalling the request body to a new chat request"
		api.BindApiErrorResponse(context, errMsg, http.StatusBadRequest, api.ErrorCodeBadRequest, err)
		return
	}

	// Since each chat is tied to a single assistant, to start a new chat we will
	// create a new assistant.
	assistant, err := assistant.NewAssistant(openaiClient, nil, request.Task)
	if err != nil {
		errMsg := "An error occurred while creating a new chat assistant"
		api.BindApiErrorResponse(context, errMsg, http.StatusInternalServerError, api.ErrorCodeGeneralError, err)
		return
	}
	assistant, err = assistantRepository.Save(assistant)
	if err != nil {
		errMsg := "An error occurred while creating the chat"
		api.BindApiErrorResponse(context, errMsg, http.StatusInternalServerError, api.ErrorCodeGeneralError, err)
		return
	}

	context.IndentedJSON(http.StatusCreated, &NewChatResponse{
		Id:   assistant.Id,
		Text: assistant.Chat.GetLastMessage().Text,
	})
	responseHeaders := map[string]string{"Location": "https://api.superu.ai/v1/chat/%s"}
	if err := context.BindHeader(responseHeaders); err != nil {
		errMsg := "An error occurred while binding the HTTP headers"
		api.BindApiErrorResponse(context, errMsg, http.StatusInternalServerError, api.ErrorCodeGeneralError, err)
	}
}

func HandleUserMessage(context *gin.Context) {
	slog.Debug("Received a new request to respond to a user message")
	userMessage := chat.NewEmptyUserMessage()
	if err := context.BindJSON(userMessage); err != nil {
		errMsg := "An error occurred while unmarshalling the request body to a chat message"
		api.BindApiErrorResponse(context, errMsg, http.StatusBadRequest, api.ErrorCodeBadRequest, err)
	}

	chatId := context.Param("id")
	if chatId == "" {
		errMsg := "No chat ID was specified in the request URI"
		slog.Error(errMsg)
		context.IndentedJSON(http.StatusNotFound, api.NewApiError(chatNotFound, errMsg))
	}
	// Remember that each chat is belongs to an assistant, so the id in the request is really the
	// assistant's id
	chatAssistant, err := assistantRepository.Get(chatId)
	if err != nil {
		errMsg := "An error occurred while loading the assistant state from the database"
		slog.Error(errMsg)
		context.IndentedJSON(http.StatusInternalServerError, api.NewApiError(api.ErrorCodeGeneralError, errMsg))
	}
	assistantMessage, err := chatAssistant.Respond(userMessage)
	if err != nil {
		slog.Error("An error occurred while the assistant was responding: %v", err)
	}
	assistantRepository.Update(chatAssistant, 2)

	context.IndentedJSON(http.StatusOK, assistantMessage)
	return
}
